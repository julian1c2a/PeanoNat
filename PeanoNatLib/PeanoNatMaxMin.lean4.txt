import PeanoNatLib.PeanoNatAxioms
import PeanoNatLib.PeanoNatStrictOrder
import PeanoNatLib.PeanoNatOrder
import Init.Prelude
import Init.Data.Nat.Basic
import Init.Data.Nat.Lemmas

open Peano
namespace Peano

    /--! def Œõ(n : Nat) : ‚Ñï‚ÇÄ  de_Nat_a_Pea
         def Œ®(n : ‚Ñï‚ÇÄ) : Nat  de_Pea_a_Nat !--/
    def max (n m : ‚Ñï‚ÇÄ) : ‚Ñï‚ÇÄ :=
        match n, m with
        | ùüò , m => m
        | n , ùüò => n
        | œÉ n' , œÉ m' =>
            if n' = m' then
                œÉ m'
            else if BLt n' m' then
                œÉ m'
            else
                œÉ n'

    /--! def Œõ(n : Nat) : ‚Ñï‚ÇÄ  de_Nat_a_Pea
         def Œ®(n : ‚Ñï‚ÇÄ) : Nat  de_Pea_a_Nat !--/
    def min (n m : ‚Ñï‚ÇÄ) : ‚Ñï‚ÇÄ :=
        match n, m with
        | ùüò , _ => ùüò
        | _ , ùüò => ùüò
        | œÉ n' , œÉ m' =>
            if n' = m' then
                œÉ n'
            else if BLt n' m' then
                œÉ n'
            else
                œÉ m'

    /--! def Œõ(n : Nat) : ‚Ñï‚ÇÄ  de_Nat_a_Pea
         def Œ®(n : ‚Ñï‚ÇÄ) : Nat  de_Pea_a_Nat !--/
    def min_max (n m : ‚Ñï‚ÇÄ) : ‚Ñï‚ÇÄ√ó‚Ñï‚ÇÄ :=
        match n, m with
        | ùüò , m => (ùüò , m)
        | n , ùüò => (ùüò , n)
        | œÉ n' , œÉ m' =>
            if n' = m' then
                (œÉ n' , œÉ n')
            else if BLt n' m' then
                (œÉ n' , œÉ m')
            else
                (œÉ m' , œÉ n')

    /--! def Œõ(n : Nat) : ‚Ñï‚ÇÄ  de_Nat_a_Pea
         def Œ®(n : ‚Ñï‚ÇÄ) : Nat  de_Pea_a_Nat !--/
    def max_min (n m : ‚Ñï‚ÇÄ) : ‚Ñï‚ÇÄ√ó‚Ñï‚ÇÄ :=
        match n, m with
        | ùüò , m => (m , ùüò)
        | n , ùüò => (n , ùüò)
        | œÉ n' , œÉ m' =>
            if n' = m' then
                (œÉ n' , œÉ n')
            else if BLt n' m' then
                (œÉ m' , œÉ n')
            else
                (œÉ n' , œÉ m')


theorem max_idem(n : ‚Ñï‚ÇÄ) : max n n = n := by
  induction n with
  | zero =>
    simp [max]
  | succ n' n_ih =>
    simp [max]

theorem min_idem(n : ‚Ñï‚ÇÄ) : min n n = n := by
  induction n with
  | zero =>
    simp [min]
  | succ n' n_ih =>
    simp [min]

theorem min_abs_0(n : ‚Ñï‚ÇÄ) : min ùüò n = ùüò := by
  induction n with
  | zero =>
    simp [min]
  | succ n' n_ih =>
    simp [min]

theorem min_0_abs(n : ‚Ñï‚ÇÄ) : min n ùüò = ùüò := by
  induction n with
  | zero =>
    rfl
  | succ n' n_ih =>
    simp [min]

theorem max_not_0(n : ‚Ñï‚ÇÄ) : max ùüò n = n := by
  induction n with
  | zero =>
    simp [max]
  | succ n' n_ih =>
    simp [max]

theorem max_0_not(n : ‚Ñï‚ÇÄ) : max n ùüò = n := by
  induction n with
  | zero =>
    simp [max]
  | succ n' n_ih =>
    simp [max]

theorem eq_max_min_then_eq(n m : ‚Ñï‚ÇÄ) :
    (max n m = min n m) ‚Üí (n = m)
        := by
    by_cases h_eq_or_neq : (n = m)
    ¬∑ -- Caso n = m.
      intro h_hyp
      exact h_eq_or_neq
    ¬∑ -- Caso n ‚â† m.
      intro h_max_eq_min_hyp
      exfalso
      cases n with
      | zero =>
        cases m with
        | zero =>
            apply h_eq_or_neq
            rfl
        | succ m' =>
          simp [max, min] at h_max_eq_min_hyp
      | succ n' =>
          cases m with
        | zero =>
          simp [max, min] at h_max_eq_min_hyp
        | succ m' =>
          have h_neq_preds : n' ‚â† m' := by
            intro h_preds_eq_contra
            apply h_eq_or_neq
            rw [h_preds_eq_contra]
          simp [max, min, if_neg h_neq_preds] at h_max_eq_min_hyp
          by_cases h_blt_eval : BLt n' m'
          ¬∑ -- Caso BLt n' m' = true
            simp [h_blt_eval] at h_max_eq_min_hyp
            have h_preds_eq_from_hyp : m' = n' :=
              h_max_eq_min_hyp
            exact h_neq_preds (Eq.symm h_preds_eq_from_hyp)
          ¬∑ -- Caso BLt n' m' = false
            simp [h_blt_eval] at h_max_eq_min_hyp
            have h_preds_eq_from_sigma_inj : n' = m' :=
              h_max_eq_min_hyp
            exact h_neq_preds h_preds_eq_from_sigma_inj

theorem eq_then_eq_max_min(n m : ‚Ñï‚ÇÄ) :
    (n = m) ‚Üí (max n m = min n m)
    := by
    intro h_eq_args
    rw [h_eq_args] -- El objetivo se convierte en: max m m = min m m
    rw [max_idem m]  -- El lado izquierdo (max m m) se convierte en m. Objetivo: m = min m m
    rw [min_idem m]  -- El lado derecho (min m m) se convierte en m. Objetivo: m = m
    -- Esto se cierra por reflexividad.

theorem eq_iff_eq_max_min(n m : ‚Ñï‚ÇÄ) :
    n = m ‚Üî max n m = min n m
        := by
        constructor
        ¬∑ -- Caso n = m ‚Üí max n m = min n m
          intro h_eq_args
          exact eq_then_eq_max_min n m h_eq_args
        ¬∑ -- Caso max n m = min n m ‚Üí n = m
          intro h_hyp_max_eq_min
          exact eq_max_min_then_eq n m h_hyp_max_eq_min

theorem min_of_min_max(n m : ‚Ñï‚ÇÄ) :
    min n m = min (max n m) (min n m)
      := by
        induction n with
        | zero =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                simp [min, max]
        | succ n' n_ih =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                by_cases h_eq_preds : (n' = m')
                ¬∑ -- Caso: n' = m'
                  simp [min, max, h_eq_preds]
                ¬∑ -- Caso: n' ‚â† m'
                  by_cases h_blt_bool : (BLt n' m')
                  ¬∑ -- Caso: BLt n' m' = true
                    have h_lt_n_prime_m_prime : Lt n' m' := by
                      rw [‚Üê BLt_iff_Lt]
                      exact h_blt_bool
                    have h_not_lt_m_prime_n_prime : ¬¨ (Lt m' n') := by
                      apply lt_asymm
                      exact h_lt_n_prime_m_prime
                    have h_blt_m_prime_n_prime_is_false :
                      BLt m' n' = false
                      := by
                         rw [‚Üê Bool.not_eq_true]
                         --   Meta: ¬¨ (BLt m' n' = true)
                         rw [BLt_iff_Lt]
                         --   Meta: ¬¨ (Lt m' n')
                         exact h_not_lt_m_prime_n_prime
                    simp [
                          min,
                          max,
                          h_eq_preds,
                          Ne.symm h_eq_preds,
                          h_blt_bool, h_blt_m_prime_n_prime_is_false
                    ]
                  ¬∑ -- Caso: ¬¨ (BLt n' m')
                    simp [
                            min,
                            max,
                            h_eq_preds,
                            h_blt_bool
                    ]

theorem max_of_min_max(n m : ‚Ñï‚ÇÄ) :
    max n m = max (min n m) (max n m)
      := by
        induction n with
        | zero =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                simp only [min, max]
        | succ n' n_ih =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                by_cases h_eq_preds : (n' = m')
                ¬∑ -- Caso: n' = m'
                  simp [min, max, h_eq_preds]
                ¬∑ -- Caso: n' ‚â† m'
                  by_cases h_blt_bool : (BLt n' m')
                  ¬∑ -- Caso: BLt n' m' = true
                    have h_lt_n_prime_m_prime : Lt n' m' := by
                      rw [‚Üê BLt_iff_Lt]
                      exact h_blt_bool
                    have h_not_lt_m_prime_n_prime : ¬¨ (Lt m' n') := by
                      apply lt_asymm
                      exact h_lt_n_prime_m_prime
                    have h_blt_m_prime_n_prime_is_false :
                      BLt m' n' = false
                      := by
                         rw [‚Üê Bool.not_eq_true]
                         rw [BLt_iff_Lt]
                         exact h_not_lt_m_prime_n_prime
                    simp [min, max, h_eq_preds, Ne.symm h_eq_preds, h_blt_bool, h_blt_m_prime_n_prime_is_false]
                  ¬∑ -- Caso: ¬¨ (BLt n' m')
                    have h_blt_m_n_is_true : BLt m' n' = true := by
                      rcases trichotomy n' m' with h_lt_n_m | h_eq_n_m | h_lt_m_n
                      ¬∑ -- Caso Lt n' m', contradice h_blt_bool
                        exfalso
                        apply h_blt_bool
                        rw [BLt_iff_Lt] -- o usa BLt_iff_Lt.mpr
                        exact h_lt_n_m
                      ¬∑ -- Caso n' = m', contradice h_eq_preds
                        exfalso
                        exact h_eq_preds h_eq_n_m
                      ¬∑ -- Caso Lt m' n', esto es lo que necesitamos
                        rw [BLt_iff_Lt] -- o usa BLt_iff_Lt.mpr
                        exact h_lt_m_n
                    simp [
                      min,
                      max,
                      h_eq_preds,
                      h_blt_bool,
                      h_blt_m_n_is_true
                    ]

theorem max_is_any(n m : ‚Ñï‚ÇÄ) :
    max n m = n ‚à® max n m = m
        := by
        cases n with
        | zero =>
          cases m with
          | zero => simp [max]
          | succ m' => simp [max]
        | succ n' =>
          cases m with
          | zero => simp [max]
          | succ m' =>
              dsimp [max]
              by_cases h_eq_cond : (n' = m')
              ¬∑
                rw [if_pos h_eq_cond]
                left
                rw [h_eq_cond]
              ¬∑
                rw [if_neg h_eq_cond]
                by_cases h_blt_cond : (BLt n' m')
                ¬∑
                  rw [if_pos h_blt_cond]
                  right
                  rfl
                ¬∑
                  rw [if_neg h_blt_cond]
                  left -- Cambiado de left a right
                  rfl

theorem min_is_any(n m : ‚Ñï‚ÇÄ) :
    min n m = n ‚à® min n m = m
        := by
        cases n with
        | zero =>
          cases m with
          | zero => simp [min]
          | succ m' => simp [min]
        | succ n' =>
          cases m with
          | zero => simp [min]
          | succ m' =>
              dsimp [min]
              by_cases h_eq_cond : (n' = m')
              ¬∑
                rw [if_pos h_eq_cond]
                left
                rfl
              ¬∑
                rw [if_neg h_eq_cond]
                by_cases h_blt_cond : (BLt n' m')
                ¬∑
                  rw [if_pos h_blt_cond]
                  left
                  rfl
                ¬∑
                  rw [if_neg h_blt_cond]
                  right
                  rfl

theorem lt_then_min (a b : ‚Ñï‚ÇÄ) :
    Lt a b ‚Üí min a b = a
    := by
      intro h_lt
      cases a with
      | zero => -- a = ùüò
        simp [min]
      | succ a' =>
        cases b with
        | zero => exfalso; exact nlt_n_0 _ h_lt
        | succ b' =>
          have h_lt_a'_b' : Lt a' b'
              := by simp [Lt] at h_lt; exact h_lt
          have h_a'_ne_b' : a' ‚â† b'
              := lt_then_neq a' b' h_lt_a'_b'
          simp [min, if_neg h_a'_ne_b']
          rw [(BLt_iff_Lt a' b').mpr h_lt_a'_b']
          simp

theorem min_then_le (a b : ‚Ñï‚ÇÄ) :
    min a b = a ‚Üí Le a b
    := by
      intro h_min_eq
      -- h_min_eq : min a b = a
      cases a with
      | zero => -- a = ùüò
        simp [min] at h_min_eq -- h_min_eq : ùüò = ùüò
        exact zero_le b
      | succ a' =>
        -- a = œÉ a'
        cases b with
        | zero =>
          exfalso;
          simp [min] at h_min_eq
          -- h_min_eq : œÉ a' = ùüò
          -- Por la inyectividad del constructores de tipos inductivos,
          -- esto es una contradicci√≥n directa
          exact Nat.noConfusion h_min_eq
        | succ b' =>
          have h_a'_ne_b' : a' ‚â† b'
              := by
                intro h_eq
                have h_eq_sigma : œÉ a' = œÉ b'
                    := Eq.symm h_min_eq
                have h_eq_a'_b' : a' = b'
                    := by
                        injection h_eq_sigma
                exact h_eq (Eq.symm h_eq_a'_b')
          simp [min, if_neg h_a'_ne_b']
          have h_blt_a'_b' :
            BLt a' b' = true
            := by
              rw [BLt_iff_Lt]
              apply Lt.base
          simp [h_blt_a'_b']
          apply succ_le_succ
          apply le_refl

theorem min_eq_of_lt {a b : ‚Ñï‚ÇÄ} (h : Lt a b) :
    min a b = a := by sorry

theorem max_eq_of_lt {a b : ‚Ñï‚ÇÄ} (h : Lt a b) :
    max a b = b := by sorry

theorem min_eq_of_gt {a b : ‚Ñï‚ÇÄ} (h_gt : Lt b a) :
    min a b = b := by sorry

theorem max_eq_of_gt {a b : ‚Ñï‚ÇÄ} (h_gt : Lt b a) :
    max a b = a := by sorry

theorem if_neq_then_max_xor(n m : ‚Ñï‚ÇÄ) :
    n ‚â† m ‚Üî
    ((max n m = n) ‚àß ¬¨(max n m = m))
    ‚à®
    (¬¨(max n m = n) ‚à® (max n m = m))
        := by sorry

theorem if_neq_then_min_xor(n m : ‚Ñï‚ÇÄ) :
    n ‚â† m ‚Üî
    ((min n m = n) ‚àß ¬¨(min n m = m))
    ‚à®
    (¬¨(min n m = n) ‚à® (min n m = m))
        := by sorry

theorem neq_args_then_lt_min_max(n m : ‚Ñï‚ÇÄ) :
    n ‚â† m ‚Üî Lt (min n m) (max n m )
        := by sorry

theorem max_comm(n m : ‚Ñï‚ÇÄ) :
    max n m = max m n
        := by sorry

theorem min_comm(n m : ‚Ñï‚ÇÄ) :
    min n m = min m n
        := by
        sorry

theorem max_assoc(n m k : ‚Ñï‚ÇÄ) :
    max (max n m) k = max n (max m k)
        := by
        sorry

theorem min_assoc(n m k : ‚Ñï‚ÇÄ) :
    min (min n m) k = min n (min n k)
        := by
        sorry

theorem max_distrib_min(n m k : ‚Ñï‚ÇÄ) :
    max n (min m k) = min (max n m) (max n k)
        := by
        sorry

theorem min_distrib_max(n m k : ‚Ñï‚ÇÄ) :
    min n (max m k) = max (min n m) (min n k)
        := by
        sorry

theorem min_zero_absorb(n : ‚Ñï‚ÇÄ) :
    min n ùüò = ùüò
        := by
        sorry

theorem max_zero_neutral(n : ‚Ñï‚ÇÄ) :
    max n ùüò = n
        := by
        sorry

theorem isomorph_max_Œõ(n m : Nat) :
    max (Œõ n) (Œõ m) = Œõ (Nat.max n m)
        := by
        sorry

theorem isomorph_min_Œõ(n m : Nat) :
    min (Œõ n) (Œõ m) = Œõ (Nat.min n m)
        := by
        sorry

theorem isomorph_max_Œ®(n m : ‚Ñï‚ÇÄ) :
    max (Œ® n) (Œ® m) = Œ® (max n m)
        := by
        sorry

theorem isomorph_min_Œ®(n m : ‚Ñï‚ÇÄ) :
    min (Œ® n) (Œ® m) = Œ® (min n m)
        := by
        sorry

end Peano
