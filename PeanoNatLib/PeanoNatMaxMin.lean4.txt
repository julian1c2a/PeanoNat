import PeanoNatLib.PeanoNatAxioms
import PeanoNatLib.PeanoNatStrictOrder
import PeanoNatLib.PeanoNatOrder
import Init.Prelude
import Init.Data.Nat.Basic
import Init.Data.Nat.Lemmas

open Peano
namespace Peano

    /--! def Î›(n : Nat) : â„•â‚€  de_Nat_a_Pea
         def Î¨(n : â„•â‚€) : Nat  de_Pea_a_Nat !--/
    def max (n m : â„•â‚€) : â„•â‚€ :=
        match n, m with
        | ðŸ˜ , m => m
        | n , ðŸ˜ => n
        | Ïƒ n' , Ïƒ m' =>
            if n' = m' then
                Ïƒ m'
            else if BLt n' m' then
                Ïƒ m'
            else
                Ïƒ n'

    /--! def Î›(n : Nat) : â„•â‚€  de_Nat_a_Pea
         def Î¨(n : â„•â‚€) : Nat  de_Pea_a_Nat !--/
    def min (n m : â„•â‚€) : â„•â‚€ :=
        match n, m with
        | ðŸ˜ , _ => ðŸ˜
        | _ , ðŸ˜ => ðŸ˜
        | Ïƒ n' , Ïƒ m' =>
            if n' = m' then
                Ïƒ n'
            else if BLt n' m' then
                Ïƒ n'
            else
                Ïƒ m'

    /--! def Î›(n : Nat) : â„•â‚€  de_Nat_a_Pea
         def Î¨(n : â„•â‚€) : Nat  de_Pea_a_Nat !--/
    def min_max (n m : â„•â‚€) : â„•â‚€Ã—â„•â‚€ :=
        match n, m with
        | ðŸ˜ , m => (ðŸ˜ , m)
        | n , ðŸ˜ => (ðŸ˜ , n)
        | Ïƒ n' , Ïƒ m' =>
            if n' = m' then
                (Ïƒ n' , Ïƒ n')
            else if BLt n' m' then
                (Ïƒ n' , Ïƒ m')
            else
                (Ïƒ m' , Ïƒ n')

    /--! def Î›(n : Nat) : â„•â‚€  de_Nat_a_Pea
         def Î¨(n : â„•â‚€) : Nat  de_Pea_a_Nat !--/
    def max_min (n m : â„•â‚€) : â„•â‚€Ã—â„•â‚€ :=
        match n, m with
        | ðŸ˜ , m => (m , ðŸ˜)
        | n , ðŸ˜ => (n , ðŸ˜)
        | Ïƒ n' , Ïƒ m' =>
            if n' = m' then
                (Ïƒ n' , Ïƒ n')
            else if BLt n' m' then
                (Ïƒ m' , Ïƒ n')
            else
                (Ïƒ n' , Ïƒ m')


theorem max_idem(n : â„•â‚€) : max n n = n := by
  induction n with
  | zero =>
    simp [max]
  | succ n' n_ih =>
    simp [max]

theorem min_idem(n : â„•â‚€) : min n n = n := by
  induction n with
  | zero =>
    simp [min]
  | succ n' n_ih =>
    simp [min]

theorem min_abs_0(n : â„•â‚€) : min ðŸ˜ n = ðŸ˜ := by
  induction n with
  | zero =>
    simp [min]
  | succ n' n_ih =>
    simp [min]

theorem min_0_abs(n : â„•â‚€) : min n ðŸ˜ = ðŸ˜ := by
  induction n with
  | zero =>
    rfl
  | succ n' n_ih =>
    simp [min]

theorem max_not_0(n : â„•â‚€) : max ðŸ˜ n = n := by
  induction n with
  | zero =>
    simp [max]
  | succ n' n_ih =>
    simp [max]

theorem max_0_not(n : â„•â‚€) : max n ðŸ˜ = n := by
  induction n with
  | zero =>
    simp [max]
  | succ n' n_ih =>
    simp [max]

theorem eq_max_min_then_eq(n m : â„•â‚€) :
    (max n m = min n m) â†’ (n = m)
        := by
    by_cases h_eq_or_neq : (n = m)
    Â· -- Caso n = m.
      intro h_hyp
      exact h_eq_or_neq
    Â· -- Caso n â‰  m.
      intro h_max_eq_min_hyp
      exfalso
      cases n with
      | zero =>
        cases m with
        | zero =>
            apply h_eq_or_neq
            rfl
        | succ m' =>
          simp [max, min] at h_max_eq_min_hyp
      | succ n' =>
          cases m with
        | zero =>
          simp [max, min] at h_max_eq_min_hyp
        | succ m' =>
          have h_neq_preds : n' â‰  m' := by
            intro h_preds_eq_contra
            apply h_eq_or_neq
            rw [h_preds_eq_contra]
          simp [max, min, if_neg h_neq_preds] at h_max_eq_min_hyp
          by_cases h_blt_eval : BLt n' m'
          Â· -- Caso BLt n' m' = true
            simp [h_blt_eval] at h_max_eq_min_hyp
            have h_preds_eq_from_hyp : m' = n' :=
              h_max_eq_min_hyp
            exact h_neq_preds (Eq.symm h_preds_eq_from_hyp)
          Â· -- Caso BLt n' m' = false
            simp [h_blt_eval] at h_max_eq_min_hyp
            have h_preds_eq_from_sigma_inj : n' = m' :=
              h_max_eq_min_hyp
            exact h_neq_preds h_preds_eq_from_sigma_inj

theorem eq_then_eq_max_min(n m : â„•â‚€) :
    (n = m) â†’ (max n m = min n m)
    := by
    intro h_eq_args
    rw [h_eq_args] -- El objetivo se convierte en: max m m = min m m
    rw [max_idem m]  -- El lado izquierdo (max m m) se convierte en m. Objetivo: m = min m m
    rw [min_idem m]  -- El lado derecho (min m m) se convierte en m. Objetivo: m = m
    -- Esto se cierra por reflexividad.

theorem eq_iff_eq_max_min(n m : â„•â‚€) :
    n = m â†” max n m = min n m
        := by
        constructor
        Â· -- Caso n = m â†’ max n m = min n m
          intro h_eq_args
          exact eq_then_eq_max_min n m h_eq_args
        Â· -- Caso max n m = min n m â†’ n = m
          intro h_hyp_max_eq_min
          exact eq_max_min_then_eq n m h_hyp_max_eq_min

theorem min_of_min_max(n m : â„•â‚€) :
    min n m = min (max n m) (min n m)
      := by
        induction n with
        | zero =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                simp [min, max]
        | succ n' n_ih =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                by_cases h_eq_preds : (n' = m')
                Â· -- Caso: n' = m'
                  simp [min, max, h_eq_preds]
                Â· -- Caso: n' â‰  m'
                  by_cases h_blt_bool : (BLt n' m')
                  Â· -- Caso: BLt n' m' = true
                    have h_lt_n_prime_m_prime : Lt n' m' := by
                      rw [â† BLt_iff_Lt]
                      exact h_blt_bool
                    have h_not_lt_m_prime_n_prime : Â¬ (Lt m' n') := by
                      apply lt_asymm
                      exact h_lt_n_prime_m_prime
                    have h_blt_m_prime_n_prime_is_false :
                      BLt m' n' = false
                      := by
                         rw [â† Bool.not_eq_true]
                         --   Meta: Â¬ (BLt m' n' = true)
                         rw [BLt_iff_Lt]
                         --   Meta: Â¬ (Lt m' n')
                         exact h_not_lt_m_prime_n_prime
                    simp [
                          min,
                          max,
                          h_eq_preds,
                          Ne.symm h_eq_preds,
                          h_blt_bool, h_blt_m_prime_n_prime_is_false
                    ]
                  Â· -- Caso: Â¬ (BLt n' m')
                    simp [
                            min,
                            max,
                            h_eq_preds,
                            h_blt_bool
                    ]

theorem max_of_min_max(n m : â„•â‚€) :
    max n m = max (min n m) (max n m)
      := by
        induction n with
        | zero =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                simp only [min, max]
        | succ n' n_ih =>
            induction m with
            | zero =>
                simp [min, max]
            | succ m' =>
                by_cases h_eq_preds : (n' = m')
                Â· -- Caso: n' = m'
                  simp [min, max, h_eq_preds]
                Â· -- Caso: n' â‰  m'
                  by_cases h_blt_bool : (BLt n' m')
                  Â· -- Caso: BLt n' m' = true
                    have h_lt_n_prime_m_prime : Lt n' m' := by
                      rw [â† BLt_iff_Lt]
                      exact h_blt_bool
                    have h_not_lt_m_prime_n_prime : Â¬ (Lt m' n') := by
                      apply lt_asymm
                      exact h_lt_n_prime_m_prime
                    have h_blt_m_prime_n_prime_is_false :
                      BLt m' n' = false
                      := by
                         rw [â† Bool.not_eq_true]
                         rw [BLt_iff_Lt]
                         exact h_not_lt_m_prime_n_prime
                    simp [min, max, h_eq_preds, Ne.symm h_eq_preds, h_blt_bool, h_blt_m_prime_n_prime_is_false]
                  Â· -- Caso: Â¬ (BLt n' m')
                    have h_blt_m_n_is_true : BLt m' n' = true := by
                      rcases trichotomy n' m' with h_lt_n_m | h_eq_n_m | h_lt_m_n
                      Â· -- Caso Lt n' m', contradice h_blt_bool
                        exfalso
                        apply h_blt_bool
                        rw [BLt_iff_Lt] -- o usa BLt_iff_Lt.mpr
                        exact h_lt_n_m
                      Â· -- Caso n' = m', contradice h_eq_preds
                        exfalso
                        exact h_eq_preds h_eq_n_m
                      Â· -- Caso Lt m' n', esto es lo que necesitamos
                        rw [BLt_iff_Lt] -- o usa BLt_iff_Lt.mpr
                        exact h_lt_m_n
                    simp [
                      min,
                      max,
                      h_eq_preds,
                      h_blt_bool,
                      h_blt_m_n_is_true
                    ]

theorem max_is_any(n m : â„•â‚€) :
    max n m = n âˆ¨ max n m = m
        := by
        cases n with
        | zero =>
          cases m with
          | zero => simp [max]
          | succ m' => simp [max]
        | succ n' =>
          cases m with
          | zero => simp [max]
          | succ m' =>
              dsimp [max]
              by_cases h_eq_cond : (n' = m')
              Â·
                rw [if_pos h_eq_cond]
                left
                rw [h_eq_cond]
              Â·
                rw [if_neg h_eq_cond]
                by_cases h_blt_cond : (BLt n' m')
                Â·
                  rw [if_pos h_blt_cond]
                  right
                  rfl
                Â·
                  rw [if_neg h_blt_cond]
                  left -- Revertido a `left`
                  rfl

theorem min_is_any(n m : â„•â‚€) :
    min n m = n âˆ¨ min n m = m
        := by
        cases n with
        | zero =>
          cases m with
          | zero => simp [min]
          | succ m' => simp [min]
        | succ n' =>
          cases m with
          | zero => simp [min]
          | succ m' =>
              dsimp [min]
              by_cases h_eq_cond : (n' = m')
              Â·
                rw [if_pos h_eq_cond]
                left
                rfl
              Â·
                rw [if_neg h_eq_cond]
                by_cases h_blt_cond : (BLt n' m')
                Â·
                  rw [if_pos h_blt_cond]
                  left
                  rfl
                Â·
                  rw [if_neg h_blt_cond]
                  right
                  rfl



theorem lt_then_min (a b : â„•â‚€) :
    Lt a b â†’ min a b = a
    := by
      intro h_lt
      cases a with
      | zero => -- a = ðŸ˜
        simp [min]
      | succ a' =>
        cases b with
        | zero => exfalso; exact nlt_n_0 (Ïƒ a') h_lt
        | succ b' =>
          have h_lt_a'_b' : Lt a' b' := by simp [Lt] at h_lt; exact h_lt
          have h_a'_ne_b' : a' â‰  b' := lt_then_neq a' b' h_lt_a'_b'
          simp [min, if_neg h_a'_ne_b']
          rw [(BLt_iff_Lt a' b').mpr h_lt_a'_b']
          simp

theorem min_then_le (a b : â„•â‚€) :
    min a b = a â†’ Le a b
    := by
      intro h_min_eq
      -- h_min_eq : min a b = a
      cases a with
      | zero => -- a = ðŸ˜
        -- Si a es cero, entonces min ðŸ˜ b es ðŸ˜ por la definiciÃ³n de `min`.
        -- h_min_eq se convierte en `ðŸ˜ = ðŸ˜`, que es trivial.
        simp only [min] at h_min_eq -- Usamos `simp only` para ser mÃ¡s especÃ­ficos
        -- Queremos probar `Le ðŸ˜ b`. Esto se cumple por el teorema `zero_le`.
        -- Usamos `exact` porque `zero_le b` ya es una prueba de `Le ðŸ˜ b`.
        exact zero_le b
      | succ a' =>
        -- a = Ïƒ a'
        -- Si 'a' es un sucesor, 'b' no puede ser cero. Si `b` fuera `ðŸ˜`, entonces `min (Ïƒ a') ðŸ˜` serÃ­a `ðŸ˜`.
        -- Esto harÃ­a que `h_min_eq` fuera `Ïƒ a' = ðŸ˜`, lo cual es una contradicciÃ³n por `succ_neq_zero`.
        cases b with
        | zero =>
          exfalso
          simp only [min] at h_min_eq -- simplifica min (Ïƒ a') ðŸ˜ a ðŸ˜
          -- h_min_eq : Ïƒ a' = ðŸ˜. Esto es una contradicciÃ³n.
          -- Usamos .symm para que la igualdad tenga la direcciÃ³n esperada por `succ_neq_zero`.
          exact succ_neq_zero a' h_min_eq.symm
        | succ b' =>
          -- a = Ïƒ a' y b = Ïƒ b'.
          -- Ahora tenemos h_min_eq : min (Ïƒ a') (Ïƒ b') = Ïƒ a'.
          -- Usaremos `by_cases` para considerar si `a' = b'` o no.
          by_cases h_eq_preds : (a' = b')
          Â· -- Caso h_eq_preds : a' = b'
            -- Si a' = b', entonces min (Ïƒ a') (Ïƒ b') se convierte en min (Ïƒ a') (Ïƒ a').
            -- Por `min_idem`, min (Ïƒ a') (Ïƒ a') es Ïƒ a'.
            -- Esto hace que `h_min_eq` sea `Ïƒ a' = Ïƒ a'`, que es `rfl`.
            simp only [min, h_eq_preds] at h_min_eq -- h_min_eq se resuelve como `rfl`
            -- Queremos demostrar `Le (Ïƒ a') (Ïƒ b')`. Como `a' = b'`, esto es `Le (Ïƒ a') (Ïƒ a')`.
            -- Esto se cumple por la definiciÃ³n de `Le` y `rfl`.
            rw [h_eq_preds] -- Aplicar la igualdad al objetivo para que sea Le (Ïƒ a') (Ïƒ a')
            exact Or.inr rfl -- Le X X es X = X, que es rfl.
          Â· -- Caso Â¬ h_eq_preds : a' â‰  b'
            -- En este caso, el primer `if` en la definiciÃ³n de `min` es falso.
            simp only [min, if_neg h_eq_preds] at h_min_eq
            -- Ahora h_min_eq es `(if BLt a' b' then Ïƒ a' else Ïƒ b') = Ïƒ a'`.
            -- Esto implica que `BLt a' b'` debe ser `true`. Si fuera `false`, entonces `Ïƒ b'` serÃ­a igual a `Ïƒ a'`, lo que contradirÃ­a `a' â‰  b'`.
            have h_blt_a'_b' : BLt a' b' = true := by
              by_cases h_blt_eval : BLt a' b'
              Â· -- h_blt_eval : BLt a' b' = true. Este es el caso que queremos.
                exact h_blt_eval
              Â· -- h_blt_eval : BLt a' b' = false
                -- Si `BLt a' b'` es `false`, entonces `min (Ïƒ a') (Ïƒ b')` es `Ïƒ b'`.
                simp only [h_blt_eval] at h_min_eq
                -- h_min_eq : Ïƒ b' = Ïƒ a'.
                -- Aplicamos AXIOM_succ_inj directamente a h_min_eq para obtener b' = a'.
                have h_b'_eq_a' : b' = a' := AXIOM_succ_inj b' a' h_min_eq
                -- Ahora tenemos `h_b'_eq_a' : b' = a'` y `h_eq_preds : a' â‰  b'`.
                -- Queremos probar `BLt a' b' = true` (el objetivo de este `have` bloque).
                -- Tenemos una contradicciÃ³n: `h_eq_preds` (a' â‰  b') y `h_b'_eq_a'` (b' = a', que es lo mismo que a' = b').
                -- Aplicamos `False.elim` para resolver el objetivo de este sub-prueba.
                exact False.elim (h_eq_preds h_b'_eq_a'.symm) -- Usamos .symm para que la igualdad coincida con h_eq_preds
            -- Ahora que sabemos que `BLt a' b' = true`, por `BLt_iff_Lt`, tenemos `Lt a' b'`.
            have h_lt_a'_b' : Lt a' b' := (BLt_iff_Lt a' b').mp h_blt_a'_b'
            -- Queremos demostrar `Le (Ïƒ a') (Ïƒ b')`.
            -- Esto es equivalente a `Le a' b'` por `succ_le_succ_iff`.
            rw [succ_le_succ_iff]
            -- Y `Le a' b'` se cumple porque `Lt a' b'` implica `Le a' b'` por `lt_imp_le`.
            exact lt_imp_le a' b' h_lt_a'_b'

theorem min_eq_of_gt {a b : â„•â‚€} (h_gt : Lt b a) :
    min a b = b := by
      cases a with
      | zero =>
        exfalso
        exact nlt_n_0 b h_gt
      | succ a' =>
        cases b with
        | zero =>
          simp [min]
        | succ b' =>
          have h_lt_b'_a' : Lt b' a' := (lt_iff_lt_Ïƒ_Ïƒ b' a').mp h_gt
          have h_b'_ne_a' : b' â‰  a' := lt_then_neq b' a' h_lt_b'_a'
          have h_not_lt_a'_b' : Â¬(Lt a' b') := lt_asymm b' a' h_lt_b'_a'
          have h_blt_a'_b'_is_false : BLt a' b' = false := (nBLt_iff_nLt a' b').mpr h_not_lt_a'_b'

          -- Simplify the first `if` condition (n' = m')
          simp only [min, if_neg h_b'_ne_a'.symm]
          -- The goal is now `(if BLt a' b' then Ïƒ a' else Ïƒ b') = Ïƒ b'`.
          -- We know `BLt a' b' = false`, so the `if` should evaluate to `Ïƒ b'`.
          -- Use `rw` to replace `BLt a' b'` with `false` in the goal, then `simp`.
          rw [h_blt_a'_b'_is_false]
          simp

theorem max_eq_of_lt {a b : â„•â‚€} (h_lt : Lt a b) :
    max a b = b := by
      cases a with
      | zero => -- a = ðŸ˜
        simp [max]
      | succ a' => -- a = Ïƒ a'
        cases b with
        | zero => -- b = ðŸ˜
          exfalso
          exact nlt_n_0 (Ïƒ a') h_lt
        | succ b' => -- a = Ïƒ a', b = Ïƒ b'
          -- Lt (Ïƒ a') (Ïƒ b') â†” Lt a' b'
          have h_lt_preds : Lt a' b' := (lt_iff_lt_Ïƒ_Ïƒ a' b').mp h_lt
          have h_a'_ne_b' : a' â‰  b' := lt_then_neq a' b' h_lt_preds
          simp [max, if_neg h_a'_ne_b']
          have h_blt_a'_b'_is_true : BLt a' b' = true := (BLt_iff_Lt a' b').mpr h_lt_preds
          rw [h_blt_a'_b'_is_true]
          simp


theorem max_eq_of_gt {a b : â„•â‚€} (h_gt : Lt b a) :
    max a b = a := by
      cases a with
      | zero =>
        exfalso
        exact nlt_n_0 b h_gt
      | succ a' =>
        cases b with
        | zero =>
          simp [max]
        | succ b' =>
          have h_lt_b'_a' : Lt b' a' := (lt_iff_lt_Ïƒ_Ïƒ b' a').mp h_gt
          have h_b'_ne_a' : b' â‰  a' := lt_then_neq b' a' h_lt_b'_a'
          have h_not_lt_a'_b' : Â¬(Lt a' b') := lt_asymm b' a' h_lt_b'_a'
          have h_blt_a'_b'_is_false : BLt a' b' = false := (nBLt_iff_nLt a' b').mpr h_not_lt_a'_b'

          -- Simplify the first `if` condition (n' = m')
          simp only [max, if_neg h_b'_ne_a'.symm]
          -- The goal is now `(if BLt a' b' then Ïƒ b' else Ïƒ a') = Ïƒ a'`.
          -- We know `BLt a' b' = false`, so the `if` should evaluate to `Ïƒ a'`.
          -- Use `rw` to replace `BLt a' b'` with `false` in the goal, then `simp`.
          rw [h_blt_a'_b'_is_false]
          simp

theorem if_neq_then_max_xor(n m : â„•â‚€) :
    n â‰  m â†”
    ((max n m = n) âˆ§ Â¬(max n m = m))
    âˆ¨
    (Â¬(max n m = n) âˆ§ (max n m = m))
    := by
      constructor
      Â· -- DirecciÃ³n â†’: n â‰  m â†’ ((max n m = n) âˆ§ Â¬(max n m = m)) âˆ¨ (Â¬(max n m = n) âˆ§ (max n m = m))
        intro h_neq_nm
        -- Usamos by_cases para la igualdad, y luego neq_then_lt_or_gt.
        by_cases h_eq_nm_case : n = m
        Â· -- Caso: n = m. Esto contradice h_neq_nm.
          exfalso
          exact h_neq_nm h_eq_nm_case
        Â· -- Caso: n â‰  m (que es h_eq_nm_case, si lo renombramos)
          -- Sabemos que si n â‰  m, entonces o Lt n m o Lt m n (por neq_then_lt_or_gt).
          have h_lt_or_gt := neq_then_lt_or_gt n m h_eq_nm_case
          cases h_lt_or_gt with
          | inl h_lt_nm => -- Caso: Lt n m (n < m)
            -- Esperamos la segunda disyunciÃ³n: (Â¬(max n m = n) âˆ§ (max n m = m))
            apply Or.inr
            constructor
            Â· -- Subobjetivo 1: Â¬(max n m = n)
              intro h_max_eq_n_contra
              -- Sabemos que max n m = m por max_eq_of_lt h_lt_nm
              have h_max_eq_m_true : max n m = m := max_eq_of_lt h_lt_nm
              -- Entonces, si max n m = n, se sigue que n = m. Contradice h_eq_nm_case.
              exact h_eq_nm_case (h_max_eq_n_contra.symm.trans h_max_eq_m_true)
            Â· -- Subobjetivo 2: max n m = m
              exact max_eq_of_lt h_lt_nm
          | inr h_lt_mn => -- Caso: Lt m n (m < n)
            -- Esperamos la primera disyunciÃ³n: ((max n m = n) âˆ§ Â¬(max n m = m))
            apply Or.inl
            constructor
            Â· -- Subobjetivo 1: max n m = n
              exact max_eq_of_gt h_lt_mn
            Â· -- Subobjetivo 2: Â¬(max n m = m)
              intro h_max_eq_m_contra
              -- Sabemos que max n m = n por max_eq_of_gt h_lt_mn
              have h_max_eq_n_true : max n m = n := max_eq_of_gt h_lt_mn
              -- Entonces, si max n m = m, se sigue que m = n. Contradice h_eq_nm_case.
              exact h_eq_nm_case (h_max_eq_m_contra.symm.trans h_max_eq_n_true).symm

      Â· -- DirecciÃ³n â†: ((max n m = n) âˆ§ Â¬(max n m = m)) âˆ¨ (Â¬(max n m = n) âˆ§ (max n m = m)) â†’ n â‰  m
        intro h_disj
        -- Queremos probar n â‰  m. Asumimos n = m y derivamos False.
        intro h_eq_nm_contra -- h_eq_nm_contra : n = m
        cases h_disj with
        | inl h_and1 =>
          -- h_and1 : (max n m = n) âˆ§ Â¬(max n m = m)
          have h_not_max_eq_m : Â¬(max n m = m) := h_and1.right
          -- Si n = m, entonces max n m = max n n = n (por max_idem).
          -- Y como n = m, max n m = m. Esto contradice h_not_max_eq_m.
          have h_max_n_m_eq_m_true : max n m = m := by rw [h_eq_nm_contra]; exact max_idem m
          exact h_not_max_eq_m h_max_n_m_eq_m_true
        | inr h_and2 =>
          -- h_and2 : (Â¬(max n m = n) âˆ§ (max n m = m))
          have h_not_max_eq_n : Â¬(max n m = n) := h_and2.left
          -- Si n = m, entonces max n m = n (por max_idem).
          -- Esto contradice h_not_max_eq_n.
          have h_max_n_m_eq_n_true : max n m = n
            := by
              rw [h_eq_nm_contra]
              exact max_idem m
          exact h_not_max_eq_n h_max_n_m_eq_n_true



theorem if_neq_then_min_xor(n m : â„•â‚€) :
    n â‰  m â†”
    ((min n m = n) âˆ§ Â¬(min n m = m))
    âˆ¨
    (Â¬(min n m = n) âˆ§ (min n m = m))
    := by
      constructor
      Â· -- DirecciÃ³n â†’: n â‰  m â†’ ((min n m = n) âˆ§ Â¬(min n m = m)) âˆ¨ (Â¬(min n m = n) âˆ§ (min n m = m))
        intro h_neq_nm
        by_cases h_eq_nm_case : n = m
        Â· -- Caso: n = m. Esto contradice h_neq_nm.
          exfalso
          exact h_neq_nm h_eq_nm_case
        Â· -- Caso: n â‰  m
          have h_lt_or_gt := neq_then_lt_or_gt n m h_eq_nm_case
          cases h_lt_or_gt with
          | inl h_lt_nm => -- Caso: Lt n m (n < m)
            -- Esperamos la primera disyunciÃ³n: ((min n m = n) âˆ§ Â¬(min n m = m))
            apply Or.inl
            constructor
            Â· -- Subobjetivo 1: min n m = n
              exact lt_then_min n m h_lt_nm
            Â· -- Subobjetivo 2: Â¬(min n m = m)
              intro h_min_eq_m_contra
              -- Sabemos que min n m = n por lt_then_min h_lt_nm
              have h_min_eq_n_true : min n m = n := lt_then_min n m h_lt_nm
              -- Si min n m = m, entonces n = m. Contradice h_eq_nm_case.
              exact h_eq_nm_case ((h_min_eq_m_contra.symm.trans h_min_eq_n_true).symm)
          | inr h_lt_mn => -- Caso: Lt m n (m < n)
            -- Esperamos la segunda disyunciÃ³n: (Â¬(min n m = n) âˆ§ (min n m = m))
            apply Or.inr
            constructor
            Â· -- Subobjetivo 1: Â¬(min n m = n)
              intro h_min_eq_n_contra
              -- Sabemos que min n m = m por min_eq_of_gt h_lt_mn
              have h_min_eq_m_true : min n m = m := min_eq_of_gt h_lt_mn
              -- Si min n m = n, entonces m = n. Contradice h_eq_nm_case.
              exact h_eq_nm_case (h_min_eq_n_contra.symm.trans h_min_eq_m_true)
            Â· -- Subobjetivo 2: min n m = m
              exact min_eq_of_gt h_lt_mn

      Â· -- DirecciÃ³n â†: ((min n m = n) âˆ§ Â¬(min n m = m)) âˆ¨ (Â¬(min n m = n) âˆ§ (min n m = m)) â†’ n â‰  m
        intro h_disj
        -- Queremos probar n â‰  m. Asumimos n = m y derivamos False.
        intro h_eq_nm_contra -- h_eq_nm_contra : n = m
        cases h_disj with
        | inl h_and1 =>
          -- h_and1 : (min n m = n) âˆ§ Â¬(min n m = m)
          have h_not_min_eq_m : Â¬(min n m = m) := h_and1.right
          -- Si n = m, entonces min n m = min n n = n (por min_idem).
          -- Y como n = m, min n m = m. Esto contradice h_not_min_eq_m.
          have h_min_n_m_eq_m_true : min n m = m := by rw [h_eq_nm_contra]; exact min_idem m
          exact h_not_min_eq_m h_min_n_m_eq_m_true
        | inr h_and2 =>
          -- h_and2 : (Â¬(min n m = n) âˆ§ (min n m = m))
          have h_not_min_eq_n : Â¬(min n m = n) := h_and2.left
          -- Si n = m, entonces min n m = n (por min_idem).
          -- Esto contradice h_not_min_eq_n.
          have h_min_n_m_eq_n_true : min n m = n := by rw [h_eq_nm_contra]; exact min_idem m
          exact h_not_min_eq_n h_min_n_m_eq_n_true

theorem neq_args_then_lt_min_max(n m : â„•â‚€) :
    n â‰  m â†” Lt (min n m) (max n m)
    := by
      constructor
      Â· -- DirecciÃ³n â†’: n â‰  m â†’ Lt (min n m) (max n m)
        intro h_neq_nm
        -- Si n â‰  m, entonces o Lt n m o Lt m n por neq_then_lt_or_gt
        have h_lt_or_gt := neq_then_lt_or_gt n m h_neq_nm
        cases h_lt_or_gt with
        | inl h_lt_nm => -- Caso: Lt n m (n < m)
          -- En este caso, min n m = n y max n m = m
          have h_min_eq_n : min n m = n := lt_then_min n m h_lt_nm
          have h_max_eq_m : max n m = m := max_eq_of_lt h_lt_nm
          -- Reescribimos el objetivo usando estas igualdades
          rw [h_min_eq_n, h_max_eq_m]
          -- Ahora el objetivo es Lt n m, que es h_lt_nm
          exact h_lt_nm
        | inr h_lt_mn => -- Caso: Lt m n (m < n)
          -- En este caso, min n m = m y max n m = n
          have h_min_eq_m : min n m = m := min_eq_of_gt h_lt_mn
          have h_max_eq_n : max n m = n := max_eq_of_gt h_lt_mn
          -- Reescribimos el objetivo usando estas igualdades
          rw [h_min_eq_m, h_max_eq_n]
          -- Ahora el objetivo es Lt m n, que es h_lt_mn
          exact h_lt_mn

      Â· -- DirecciÃ³n â†: Lt (min n m) (max n m) â†’ n â‰  m
        intro h_lt_min_max
        -- Queremos probar n â‰  m por contradicciÃ³n
        intro h_eq_nm
        -- Si n = m, entonces min n m = max n m = n (por min_idem y max_idem)
        have h_min_eq_n : min n m = n := by rw [h_eq_nm]; exact min_idem m
        have h_max_eq_n : max n m = n := by rw [h_eq_nm]; exact max_idem m
        -- Reescribimos h_lt_min_max con estas igualdades
        rw [h_min_eq_n, h_max_eq_n] at h_lt_min_max
        -- h_lt_min_max se convierte en Lt n n, pero sabemos que Â¬(Lt n n) por lt_irrefl
        apply lt_irrefl n
        exact h_lt_min_max
          Â· -- Caso n' â‰  m'
            by_cases h_blt_nm : BLt n' m'
            Â· -- Caso BLt n' m' = true
              -- ... (este caso estÃ¡ bien, no necesita cambios) ...

            Â· -- Caso BLt n' m' = false
              -- Ahora necesitamos demostrar que BLt m' n' = true
              have h_blt_mn_true : BLt m' n' = true := by
                -- Estamos en el caso n' â‰  m' y Â¬(BLt n' m')
                -- Por tricotomÃ­a, debe ser Lt m' n'
                rcases trichotomy n' m' with h_lt | h_eq_tri | h_gt

                -- Si Lt n' m', entonces BLt n' m' = true, contradiciendo h_blt_nm
                Â· exfalso
                  have h_blt_nm_true : BLt n' m' = true := (BLt_iff_Lt n' m').mpr h_lt
                  exact h_blt_nm h_blt_nm_true

                -- Si n' = m', contradice h_eq
                Â· exfalso
                  exact h_eq h_eq_tri

                -- Si Lt m' n', entonces BLt m' n' = true, que es lo que queremos
                Â· exact (BLt_iff_Lt m' n').mpr h_gt

              -- Calculemos el lado izquierdo
              have h_max_nm : max (Ïƒ n') (Ïƒ m') = Ïƒ n' := by
                simp [max, if_neg h_eq, if_neg h_blt_nm]

              -- Calculemos el lado derecho
              have h_max_mn : max (Ïƒ m') (Ïƒ n') = Ïƒ n' := by
                simp [max, if_neg (Ne.symm h_eq)]
                -- Sabemos que BLt m' n' = true por h_blt_mn_true
                rw [h_blt_mn_true]
                -- Ahora tenemos Ïƒ n', que es lo que queremos
                rfl

              -- Ahora mostramos que ambos lados son iguales
              rw [h_max_nm, h_max_mn]

      Â· -- DirecciÃ³n â†: Lt (min n m) (max n m) â†’ n â‰  m
        intro h_lt_min_max
        -- Queremos probar n â‰  m por contradicciÃ³n
        intro h_eq_nm
        -- Si n = m, entonces min n m = max n m = n (por min_idem y max_idem)
        have h_min_eq_n : min n m = n := by rw [h_eq_nm]; exact min_idem m
        have h_max_eq_n : max n m = n := by rw [h_eq_nm]; exact max_idem m
        -- Reescribimos h_lt_min_max con estas igualdades
        rw [h_min_eq_n, h_max_eq_n] at h_lt_min_max
        -- h_lt_min_max se convierte en Lt n n, pero sabemos que Â¬(Lt n n) por lt_irrefl
        apply lt_irrefl n
        exact h_lt_min_max

theorem min_comm(n m : â„•â‚€) :
    min n m = min m n
        := by sorry

theorem max_assoc(n m k : â„•â‚€) :
    max (max n m) k = max n (max m k)
        := by sorry

theorem min_assoc(n m k : â„•â‚€) :
    min (min n m) k = min n (min n k)
        := by sorry

theorem max_distrib_min(n m k : â„•â‚€) :
    max n (min m k) = min (max n m) (max n k)
        := by sorry

theorem min_distrib_max(n m k : â„•â‚€) :
    min n (max m k) = max (min n m) (min n k)
        := by sorry

theorem min_zero_absorb(n : â„•â‚€) :
    min n ðŸ˜ = ðŸ˜
        := by sorry

theorem max_zero_neutral(n : â„•â‚€) :
    max n ðŸ˜ = n
        := by sorry

theorem nexists_max_abs:
    âˆ€ (k: â„•â‚€), âˆƒ (n: â„•â‚€) , max n k = n âˆ§ n â‰  k
        := by
          intro k
          -- Queremos probar que existe n tal que max n k = n
          -- Usamos el caso trivial: n = k
          use n := Ïƒ k
          -- Queremos probar max k k = k
          -- Esto es cierto por la propiedad de max_idem
          exact max_idem k

theorem isomorph_max_Î›(n m : Nat) :
    max (Î› n) (Î› m) = Î› (Nat.max n m)
        := by sorry

theorem isomorph_min_Î›(n m : Nat) :
    min (Î› n) (Î› m) = Î› (Nat.min n m)
        := by sorry

theorem isomorph_max_Î¨(n m : â„•â‚€) :
    max (Î¨ n) (Î¨ m) = Î¨ (max n m)
        := by sorry

theorem isomorph_min_Î¨(n m : â„•â‚€) :
    min (Î¨ n) (Î¨ m) = Î¨ (min n m)
        := by sorry

end Peano
