import PeanoNatLib.PeanoNatAxioms
import PeanoNatLib.PeanoNatStrictOrder
import PeanoNatLib.PeanoNatOrder
import PeanoNatLib.PeanoNatMaxMin

open Peano
namespace Peano

  def add (n m : â„•â‚€) : â„•â‚€ :=
    match m with
    | ðŸ˜ => n
    | Ïƒ m' => Ïƒ (add n m')

  instance : Add â„•â‚€ where
    add := Peano.add

  def add_l (n m : â„•â‚€) : â„•â‚€ :=
    match n with
    | ðŸ˜ => m
    | Ïƒ n' => Ïƒ (add n' m)

  theorem add_zero (n : â„•â‚€) : add n ðŸ˜ = n
    := by
      induction n with
      | zero => simp [add]
      | succ n' ih => simp [add]

  theorem add_zero_l (n : â„•â‚€) :
      add_l n ðŸ˜ = n
    := by
      induction n with
      | zero =>
              rfl
            | succ n' ih =>
        calc
          add_l (Ïƒ n') ðŸ˜ = Ïƒ (add n' ðŸ˜) := by simp [add_l]
          _ = Ïƒ n' := by rw [add_zero]
          _ = Ïƒ n' := rfl

  theorem zero_add (n : â„•â‚€) : add ðŸ˜ n = n
    := by
      induction n with
      | zero => simp [add]
      | succ n' ih => simp [add]; exact ih

  theorem zero_add_l (n : â„•â‚€) :
      add_l ðŸ˜ n = n
          := by
            induction n with
            | zero =>
              simp [add_l]
            | succ n' ih =>
              calc
                add_l ðŸ˜ (Ïƒ n') = Ïƒ (add_l ðŸ˜ n') := by
                  simp [add_l]
                _ = Ïƒ n' := rfl

  theorem add_zero_eq_add_l_zero (n : â„•â‚€) :
    add n ðŸ˜ = add_l n ðŸ˜
      := by
        induction n with
        | zero => rfl
        | succ n' ih =>
          simp [add, add_l, add_zero, add_zero_l]

  theorem add_one (n : â„•â‚€) : add n ðŸ™ = Ïƒ n
    := by
      induction n with
      | zero => rfl
      | succ n' ih => unfold add; rw [<-ih]; rfl

  theorem add_one_l (n : â„•â‚€) : add_l n ðŸ™ = Ïƒ n
    := by
      induction n with
      | zero =>
          rfl
      | succ n' ih => -- ih: add_l n' ðŸ™ = Ïƒ n'
                      -- Objetivo: add_l (Ïƒ n') ðŸ™ = Ïƒ (Ïƒ n')
          calc
            add_l (Ïƒ n') ðŸ™ = Ïƒ (add n' ðŸ™) := by simp [add_l]
            _ = Ïƒ (Ïƒ n') := by rw [add_one]

  theorem one_add (n : â„•â‚€) : add ðŸ™ n = Ïƒ n
    := by
      induction n with
      | zero => rfl
      | succ n' ih => unfold add; rw [<-ih]

  theorem one_add_l (n : â„•â‚€) : add_l ðŸ™ n = Ïƒ n
    := by
      induction n with
      | zero =>
          simp [add_l, one, add_zero]
      | succ n' ih => -- ih: add_l ðŸ™ n' = Ïƒ n'
                      -- Objetivo: add_l ðŸ™ (Ïƒ n') = Ïƒ (Ïƒ n')
          calc
            add_l ðŸ™ (Ïƒ n') = Ïƒ (add_l ðŸ™ n') := by simp [add_l, one, zero_add]
            _ = Ïƒ (Ïƒ n') := by rw [ih]

  theorem add_one_eq_add_l_one (n : â„•â‚€) :
    add n ðŸ™ = add_l n ðŸ™
      := by
        induction n with
        | zero => rfl
        | succ n' ih =>
          calc
            add (Ïƒ n') (Ïƒ ðŸ˜) = Ïƒ (add (Ïƒ n') ðŸ˜) := by rfl
            _ = Ïƒ (Ïƒ n') := by rw [add_zero]
            _ = Ïƒ (add_l (Ïƒ n') ðŸ˜) := by simp [add_zero_l]

  theorem add_succ (n m : â„•â‚€) : add n (Ïƒ m) = Ïƒ (add n m)
    := by
      induction n with
      | zero => simp [add]
      | succ n' ih => simp [add]

  theorem add_succ_l (n m : â„•â‚€) : add_l n (Ïƒ m) = Ïƒ (add_l n m)
    := by
      induction n with
      | zero =>
        simp [add_l]
      | succ n' ih =>
        simp [add_l] -- Esto transforma el objetivo add_l (Ïƒ n') (Ïƒ m) = Ïƒ (add_l (Ïƒ n') m)
                     -- en Ïƒ (add n' (Ïƒ m)) = Ïƒ (Ïƒ (add n' m)).
                     -- Por inyectividad de Ïƒ, esto es equivalente a add n' (Ïƒ m) = Ïƒ (add n' m).
        exact add_succ n' m -- Este es el teorema add_succ aplicado a n' y m.
      -- La hipÃ³tesis inductiva ih: add_l n' (Ïƒ m) = Ïƒ (add_l n' m) no se usa directamente aquÃ­,
      -- ya que la simplificaciÃ³n del objetivo lo alinea con otro teorema existente.

  theorem succ_add (n m : â„•â‚€) : add (Ïƒ n) m = Ïƒ (add n m)
    := by
      induction m with
      | zero => rw [add, add]
      | succ n' ih => simp [add]; rw [ih]

  theorem succ_add_l (n m : â„•â‚€) : add_l (Ïƒ n) m = Ïƒ (add_l n m) := by
    unfold add_l -- Desplegamos la definiciÃ³n de add_l en ambos lados.
    cases n with
    | zero =>
      calc
        Ïƒ (add ðŸ˜ m) = Ïƒ m := by rw [zero_add]
        _ = Ïƒ (match ðŸ˜ with | ðŸ˜ => m | Ïƒ n' => Ïƒ (add n' m)) := by simp
    | succ n' =>
      dsimp
      rw [succ_add n' m]

    theorem add_succ_eq_add_l_succ (n m: â„•â‚€) :
        add n (Ïƒ m) = add_l n (Ïƒ m)
            := by
        induction n with
        | zero => simp [add, add_l, zero_add]
        | succ n' ih =>
          calc
            add (Ïƒ n') (Ïƒ m) = Ïƒ (add (Ïƒ n') m)    := by rw [add_succ]
            _ = Ïƒ (Ïƒ (add n' m))                  := by rw [succ_add]
            _ = Ïƒ (add n' (Ïƒ m))                  := by rw [add_succ]
            _ = Ïƒ (add_l n' (Ïƒ m))                := by rw [ih]
            _ = add_l (Ïƒ n') (Ïƒ m)                := by rw [succ_add_l]

  theorem add_eq_add_l (n m : â„•â‚€) :
    add n m = add_l n m
      := by
        induction n with
        | zero => rw [zero_add, zero_add_l]
        | succ n' ih =>
          calc
            add (Ïƒ n') m = Ïƒ (add n' m) := by rw [succ_add] -- Corregido: add_succ -> succ_add
            _ = Ïƒ (add_l n' m) := by rw [ih]
            _ = add_l (Ïƒ n') m := by rw [succ_add_l]

  theorem eq_fn_add_add_l :
    âˆ€ (n m : â„•â‚€), add n m = add_l n m
      := by
        intro n m
        exact add_eq_add_l n m

  theorem add_comm (n m : â„•â‚€) : add n m = add m n
    := by
      induction n with
      | zero => rw [zero_add]; rw [add_zero]
      | succ n' ih => rw [succ_add]; rw [ih]; exact add_succ m n'

  theorem add_assoc (n m k : â„•â‚€) : add n (add m k) = add (add n m) k
    := by
      induction n with
      | zero => rw [zero_add]; rw [zero_add]
      | succ n' ih => rw [succ_add]; rw [ih]; rw [succ_add]; rw [succ_add]

  theorem add_le (a b c : â„•â‚€) : Le a b â†’ Le a (add b c) := by
    intro h_le
    induction c with
    | zero => rw [add_zero]; exact h_le
    | succ c' ih =>
        exact le_trans a (add b c') (add b (Ïƒ c')) ih (le_succ_self (add b c'))

  theorem add_lt (n m k : â„•â‚€) : Lt n m â†’ Lt n (add m k)
    := by
      intro h_lt
      induction k with
      | zero => rw [add_zero]; exact h_lt
      | succ k' ih => rw [add_succ]; exact Peano.lt_succ n (add m k') ih

  theorem add_cancelation (n m k : â„•â‚€) :
    add n m = add n k â†’ m = k
      := by
        intro h_eq
        induction n with
        | zero => rw [zero_add, zero_add] at h_eq; exact h_eq
        | succ n' ih => rw [succ_add, succ_add] at h_eq; injection h_eq with h_m_eq_k; exact ih h_m_eq_k

  theorem cancelation_add (n m k : â„•â‚€) :
    add m n = add k n â†’ m = k
      := by
        intro h_eq
        induction n with
        | zero => rw [add_zero, add_zero] at h_eq; exact h_eq
        | succ n' ih => rw [add_succ, add_succ] at h_eq; injection h_eq with h_m_eq_k; exact ih h_m_eq_k

  theorem add_lt_cancelation (n m k : â„•â‚€) :
    add n m < add n k â†’ m < k
      := by
        intro h_lt
        induction n with
        | zero => rw [zero_add, zero_add] at h_lt; exact h_lt
        | succ n' ih => rw [succ_add, succ_add] at h_lt; exact ih h_lt

  theorem add_le_cancelation (n m k : â„•â‚€) :
    (add n m) â‰¤ (add n k) â†’ m â‰¤ k
      := by
        intro h_le
        induction n with
        | zero =>
            rw [zero_add, zero_add] at h_le;
            exact h_le
        | succ n' ih => -- ih : (add n' m) â‰¤ (add n' k) â†’ m â‰¤ k
                        -- h_le : (add (Ïƒ n') m) â‰¤ (add (Ïƒ n') k)
            -- El objetivo es demostrar m â‰¤ k
            -- Primero, reescribimos h_le usando las propiedades de la suma con el sucesor.
            rw [succ_add, succ_add] at h_le -- Ahora h_le : Ïƒ (add n' m) â‰¤ Ïƒ (add n' k)
            -- Aplicamos la hipÃ³tesis inductiva 'ih'. Esto cambia el objetivo a (add n' m) â‰¤ (add n' k).
            apply ih
            -- Para demostrar (add n' m) â‰¤ (add n' k), usamos h_le y el hecho de que Ïƒ x â‰¤ Ïƒ y â†’ x â‰¤ y.
            -- Esta propiedad es provista por succ_le_succ_iff.
            exact (succ_le_succ_iff (add n' m) (add n' k)).mp h_le


  theorem add_eq_zero_iff (a b : â„•â‚€) :
    add a b = ðŸ˜ â†” a = ðŸ˜ âˆ§ b = ðŸ˜
      := by
        constructor
        Â· intro h_eq
          induction a with
          | zero =>
            rw [zero_add] at h_eq;
            exact âŸ¨rfl, h_eqâŸ©
          | succ a' ih =>
            rw [succ_add] at h_eq;
            have h_contradiction : Ïƒ (add a' b) = ðŸ˜
              := h_eq
            have h_absurd : Ïƒ (add a' b) â‰  ðŸ˜
              := succ_neq_zero (add a' b)
            contradiction
        Â· intro âŸ¨h_a_eq_zero, h_b_eq_zeroâŸ©;
          rw [h_a_eq_zero, h_b_eq_zero];
          rfl

  theorem le_then_le_add_zero (a b : â„•â‚€) :
    Le a b â†’ Le (add a ðŸ˜) (add b ðŸ˜)
      := by
        intro h_le
        induction b with
        | zero =>
            rw [add_zero, add_zero];
            exact h_le
        | succ b' ih =>
            rw [add_zero, add_zero] -- Reescribe el objetivo Le (add a 0) (add (Ïƒ b') 0) a Le a (Ïƒ b')
            exact h_le -- Ahora el objetivo coincide con la hipÃ³tesis h_le

  theorem le_then_le_add_one (a b : â„•â‚€) :
    Le a b â†’ Le (add a ðŸ™) (add b ðŸ™)
      := by
        intro h_le
        induction b with
        | zero =>
            rw [add_one, add_one]
            apply (succ_le_succ_iff _ _).mpr
            exact h_le
        | succ b' ih =>
            rw [add_one, add_one]
            apply (succ_le_succ_iff _ _).mpr
            exact h_le


  theorem le_add_then_le_add_succ (a b n: â„•â‚€) :
    Le (add a n) (add b n) â†’ Le (add a (Ïƒ n)) (add b (Ïƒ n))
      := by
        intro h_le
        induction n with
        | zero =>
            rw [add_zero, add_zero] at h_le
            rw [add_succ, add_succ] -- Objetivo: Le (Ïƒ (add a ðŸ˜)) (Ïƒ (add b ðŸ˜))
            rw [add_zero, add_zero] -- Objetivo: Le (Ïƒ a) (Ïƒ b)
            apply (succ_le_succ_iff a b).mpr -- Objetivo: Le a b
            exact h_le
        | succ n' ih =>
            rw [add_succ, add_succ]
            -- Reescribe el objetivo a Le (Ïƒ (add a (Ïƒ n'))) (Ïƒ (add b (Ïƒ n')))
            apply (succ_le_succ_iff (add a (Ïƒ n')) (add b (Ïƒ n'))).mpr
            -- Cambia el objetivo a Le (add a (Ïƒ n')) (add b (Ïƒ n'))
            exact h_le
            -- Esto es la hipÃ³tesis original h_le : Le (add a (Ïƒ n')) (add b (Ïƒ n'))

  theorem le_then_le_add (a b c: â„•â‚€) :
    Le a b â†’ Le (add a c) (add b c)
      := by
      intro h_le -- AÃ±adir intro h_le para que la hipÃ³tesis estÃ© disponible
      induction c with
      | zero =>
          rw [add_zero, add_zero]
          exact (le_then_le_add_zero a b h_le)
          -- Usar el nombre correcto del teorema y pasar la hipÃ³tesis
      | succ c' ih =>
          rw [add_succ, add_succ]
          apply (succ_le_succ_iff _ _).mpr -- Reemplaza la lÃ­nea original
          exact ih -- La hipÃ³tesis inductiva 'ih' ya es el objetivo actual

theorem le_add_zero_then_le (a b : â„•â‚€) :
    Le (add a ðŸ˜) (add b ðŸ˜) â†’ Le a b
      := by
        intro h_le
        rw [add_zero, add_zero] at h_le
        exact h_le

theorem le_add_one_then_le (a b : â„•â‚€) :
    Le (add a ðŸ™) (add b ðŸ™) â†’ Le a b
      := by
        intro h_le
        rw [add_one, add_one] at h_le
        exact (succ_le_succ_iff a b).mp h_le

theorem le_add_then_le_add_succ_then_le (a b n: â„•â‚€) :
    Le (add a n) (add b n) â†’ (Le a b)
      := by
        intro h_le_add_implies_succ -- Renombrar h_le_add para mayor claridad
        induction n with
        | zero =>
            rw [add_zero, add_zero] at h_le_add_implies_succ
            exact h_le_add_implies_succ
        | succ n' ih =>
            rw [add_succ, add_succ] at h_le_add_implies_succ
            -- Aplicamos le_of_succ_le_succ para "quitar" los Ïƒ.
            have h_base_le : Le (add a n') (add b n')
                := (succ_le_succ_iff _ _).mp h_le_add_implies_succ
            exact ih h_base_le

  theorem le_add_then_le (a b c: â„•â‚€) :
    Le (add a c) (add b c) â†’ Le a b
      := by
        intro h_le_add
        induction c with
        | zero =>
            rw [add_zero, add_zero] at h_le_add
            exact h_le_add
        | succ c' ih =>
            rw [add_succ, add_succ] at h_le_add
            -- Aplicamos le_of_succ_le_succ para "quitar" los Ïƒ.
            have h_base_le : Le (add a c') (add b c')
                := (succ_le_succ_iff _ _).mp h_le_add
            exact ih h_base_le

  theorem le_iff_le_add(a b c: â„•â‚€) :
    Le a b â†” Le (add a c) (add b c)
      := by
        constructor
        Â· intro h_le
          exact le_then_le_add a b c h_le
        Â· intro h_le_add
          exact le_add_then_le a b c h_le_add

  theorem le_iff_le_add_forall(a b : â„•â‚€) :
    âˆ€ (k : â„•â‚€), Le a b â†” Le (add a k) (add b k)
      := by
        intro k
        constructor
        Â· intro h_le
          exact le_then_le_add a b k h_le
        Â· intro h_le_add
          exact le_add_then_le a b k h_le_add


  theorem le_add_cancel (a b : â„•â‚€) :
      âˆ€ (k: â„•â‚€), Le a b â†” Le (add a k) (add b k)
        := by
        exact le_iff_le_add_forall a b

  theorem le_then_exists_zero_add (a : â„•â‚€) :
    Le a (add a ðŸ˜) â†’ Le a a
      := by
        intro h_le
        induction a with
        | zero =>
            rw [add_zero] at h_le
            exact Or.inr rfl
        | succ a' ih =>
            rw [add_zero] at h_le
            exact h_le

  theorem le_self_add (a p : â„•â‚€) : Le a (add a p) := by
    induction p with
    | zero =>
      rw [add_zero]
      exact le_refl a -- Corregido de 'reflexivity'
    | succ p' ih =>
      rw [add_succ]    -- Meta aquÃ­ es Le a (Ïƒ (add a p'))
      apply le_succ    -- Aplicar Le.succ transforma la meta a Le a (add a p')
      exact ih         -- ih tiene tipo Le a (add a p'), que ahora coincide con la meta

  theorem le_self_add_forall (a : â„•â‚€) :
    âˆ€ (p : â„•â‚€), Le a (add a p)
      := by
    intro p
    -- AquÃ­ se usa la inducciÃ³n sobre p para demostrar Le a (add a p)
    induction p with
    | zero =>
      rw [add_zero]
      exact le_refl a -- Corregido de 'reflexivity'
    | succ p' ih =>
      rw [add_succ]    -- Meta aquÃ­ es Le a (Ïƒ (add a p'))
      apply le_succ    -- Aplicar Le.succ transforma la meta a Le a (add a p')
      exact ih         -- ih tiene tipo Le a (add a p'), que ahora coincide con la meta

  theorem le_iff_exists_add (a b: â„•â‚€) :
      (Le a b) â†” âˆƒ (p : â„•â‚€), b = add a p
          := by
  constructor -- Divide el objetivo P â†” Q en dos subobjetivos: P â†’ Q y Q â†’ P
  -- Primera direcciÃ³n: (Le a b) â†’ âˆƒ (p : â„•â‚€), b = add a p
  Â· intro h_le_a_b -- Asume h_le_a_b : Le a b
    -- Probamos por inducciÃ³n sobre la prueba h_le_a_b
    induction h_le_a_b with
    -- Caso 1: h_le_a_b es (Le.refl a).
    -- En este caso, 'b' es igual a 'a' (el parÃ¡metro de Le).
    -- El objetivo se convierte en: âˆƒ (p : â„•â‚€), a = add a p
    | refl =>
      exists â„•â‚€.zero
      exact add_zero_right a -- Necesita que a + 0 = a (o como se llame tu lema)
      -- Si add_zero_right es por rfl, podrÃ­as usar: rw [add_zero_right] o rfl.

    -- Caso 2: h_le_a_b es (Le.succ a b' h_underlying).
    -- AquÃ­, la hipÃ³tesis inductiva 'ih' se aplica a 'h_underlying : Le a b''.
    -- ih : âˆƒ (p' : â„•â‚€), b' = add a p'
    -- El 'b' original de (Le a b) es (â„•â‚€.succ b').
    -- El objetivo es: âˆƒ (p : â„•â‚€), (â„•â‚€.succ b') = add a p
    | succ b_prime h_a_le_b_prime ih =>
      -- ih es la hipÃ³tesis inductiva: âˆƒ (p' : â„•â‚€), b_prime = add a p'
      cases ih with p_val h_b_prime_eq_add_a_p_val
      -- Tenemos p_val : â„•â‚€ y h_b_prime_eq_add_a_p_val : b_prime = add a p_val
      -- Queremos encontrar un 'p' tal que â„•â‚€.succ b_prime = add a p.
      -- Elegimos p = â„•â‚€.succ p_val.
      exists (â„•â‚€.succ p_val)
      -- El objetivo es ahora: â„•â‚€.succ b_prime = add a (â„•â‚€.succ p_val)
      rw [add_succ_right a p_val] -- RHS se convierte en â„•â‚€.succ (add a p_val)
                                  -- Objetivo: â„•â‚€.succ b_prime = â„•â‚€.succ (add a p_val)
      -- Usamos la igualdad h_b_prime_eq_add_a_p_val : b_prime = add a p_val
      apply congrArg â„•â‚€.succ -- Si X = Y, entonces succ X = succ Y
      exact h_b_prime_eq_add_a_p_val

  -- Segunda direcciÃ³n: (âˆƒ (p : â„•â‚€), b = add a p) â†’ Le a b
  Â· intro h_exists_p -- Asume h_exists_p : âˆƒ (p : â„•â‚€), b = add a p
    cases h_exists_p with p h_b_eq_add_a_p
    -- Tenemos p : â„•â‚€ y h_b_eq_add_a_p : b = add a p.
    -- Sustituimos 'b' en el objetivo 'Le a b'.
    -- Objetivo: Le a (add a p)
    rw [h_b_eq_add_a_p]
    -- Probamos Le a (add a p) por inducciÃ³n sobre p
    induction p with
    -- Caso base: p = â„•â‚€.zero
    -- Objetivo: Le a (add a â„•â‚€.zero)
    | zero =>
      rw [add_zero_right a] -- Objetivo: Le a a
      apply Le.refl -- Usa el constructor Le.refl (o como se llame)

    -- Paso inductivo: p = â„•â‚€.succ k
    -- HipÃ³tesis inductiva 'ih_le_a_add_a_k': Le a (add a k)
    -- Objetivo: Le a (add a (â„•â‚€.succ k))
    | succ k ih_le_a_add_a_k =>
      rw [add_succ_right a k] -- Objetivo: Le a (â„•â‚€.succ (add a k))
      apply Le.succ -- Usa el constructor Le.succ (o como se llame)
      exact ih_le_a_add_a_k -- Esto prueba la premisa de Le.succ

  theorem le_iff_exists_add (a b: â„•â‚€) :
    (Le a b) â†” âˆƒ (p : â„•â‚€), b = add a p
      := by
        constructor
        Â· intro h_le
          induction h_le with
          | inr rfl => -- Caso base: a = b (Le a a por reflexividad)
            exists ðŸ˜
            exact add_zero a
          | inl h_le_succ => -- Caso inductivo: Le a (Ïƒ m')
            -- Desempaquetamos la hipÃ³tesis inductiva
            cases h_le_succ with
            | intro m' h_le_a_m' =>
              cases h_le_a_m' with
              | intro ih_p' hp' => -- p' : â„•â‚€, hp' : m' = add a p'
                exists (Ïƒ ih_p')
                rw [hp'] -- Sustituye m' en el objetivo: Ïƒ (add a p') = add a (Ïƒ p')
                exact add_succ a ih_p' -- Esto es Ïƒ (add a p') = add a (Ïƒ p') por teorema
        Â· intro h_exists_add -- h_exists_add : âˆƒ p, b = add a p
          cases h_exists_add with
          | intro p hp_b_eq_add_a_p => -- p : â„•â‚€, hp_b_eq_add_a_p : b = add a p
            -- El objetivo es Le a b.
            rw [hp_b_eq_add_a_p] -- Sustituimos b. El objetivo se convierte en Le a (add a p).
            exact le_self_add a p -- Esto es el teorema le_self_add.

  theorem lt_add_cancel (a b : â„•â‚€) :
      âˆ€ (k: â„•â‚€), Lt (add a k) (add b k) â†” Lt a b
        := by sorry

  theorem lt_iff_exists_add_succ (a b : â„•â‚€) :
    Lt a b â†” âˆƒ p, b = add a (Ïƒ p)
      := by sorry

end Peano
